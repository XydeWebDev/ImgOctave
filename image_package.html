<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kaushan+Script&family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="img/icon.ico">
    <title>OctaveImg</title>
</head>
<body>

<header class="header" id="header">
    <div class="container">
        <div class="header__inner">
            <a class="header__logo" href="index.html">OctaveImg</a>
            <nav class="nav" id="nav">
                <a class="nav__link" href="index.html">На главную</a>
                <a class="nav__link" href="image_processing.html">Обработка изображений</a>
                <a class="nav__link" href="basic_methods.html">Основные методы</a>
                <a class="nav__link" href="image_processing_octave.html">Octave</a>
            </nav>
            <button class="nav-toggle" id="nav_toggle" type="button">
                <span class="nav-toggle__item">Menu</span>
            </button>
        </div>
    </div>
</header>

<div class="page">
    <div class="intro" id="intro">
        <div class="container">
            <div class="intro__inner">
                <h1 class="intro__title">'Image'<br>Package</h1>
            </div>
        </div>
    </div>

    <section class="section" id="image__package">
        <div class="container">
            <div class="section__header">
                <h2 class="section__title">Пакет 'Image' для обработки изображений в Octave</h2>
                <div class="section__text">
                    <h3 class="section__suptitle">Загрузка и сохранение изображений</h3>
                    <p>Первым шагом в большинстве задач обработки изображений является за-грузка изображений, что выполняется с помощью функции <strong>imread</strong>. Соответ-ствующей функцией записи на диск является функция <strong>imwrite</strong>. Такм образом, процесс обработки изображения будет следовать структуре следующего кода:</p>
                    <div class="code">
                        <code>
                            I = imread("input_image.img");<br>
                            J = process_image(I);<br>
                            imwrite(J, "output_image.img");
                        </code>
                    </div>
                    <p></p>
                    <p><strong>Загрузка изображений</strong></p>
                    <i>[image, map, alpha] = imread(filename);</i>
                    <i>[…] = imread(URL);</i>
                    <i>[…] = imread(…, format);</i>
                    <i>[…] = imread(…, idx);</i>
                    <i>[…] = imread(…, param_1, value_1, …);</i>
                    <p>Изображения читаются как матрица с помощью имени файла или URL-адреса онлайн ресурса. Если не указано ни однл из них не указано, но указано расши-рение, то ищется файл с расширением format.</p>
                    <p>Размер и класс вывода зависят от формата изображения. Цветное изображение возвращается в виде матрицы MxNx3. Оттенки серого и черно-белые изображе-ния имеют размер MxN. Многостраничные изображения будут иметь дополни-тельное 4-е измерение.</p>
                    <p>Разрядность изображения определяет класс вывода: uint8, uint16, или single для оттенков серого и цветного, и logical для черно-белого.</p>
                    <p>Некоторые форматы файлов, такие как TIFF и GIF, позволяют хранить не-сколько изображений в одном файле, он может быть скаляром или вектором, указывающим индекс изображений для чтения. По умолчанию Octave читает начальный кадр.</p>
                    <p>В зависимости от формата файла можно настроить чтение изображений с по-мощью пар параметров, значений. Поддерживаются следующие параметры:
                    <ul>
                        <li><strong>Frames</strong> или же <strong>Index</strong>. Это альтернативный метод указания format. При указании таким образом его значение также может быть строкой all.</li>
                        <li><strong>Info</strong>. Эта опция существует для совместимости с Matlab, но не имеет ни-какого эффекта. Для максимальной производительности при чтении нескольких изображений из одного файла лучше использовать параметр In-dex.</li>
                        <li><strong>PixelRegion</strong>. Управляет считываемой областью изображения. Значение должно быть массивом ячеек. Элементы массива – это начальный и ко-нечный пиксели для чтения. Если значение не указано, то оно по умолчанию равно единице.</li>
                    </ul>
                    </p>
                    <div class="code">
                        <span>
                            imread(filename, "PixelRegion", {[200 500], [400 900]});<br>
                            imread(filename, "PixelRegion", {[200 1 500], [400 1 900]});<br>
                            imread(filename)(200:500, 400:900);
                        </span>
                    </div>
                    <p><strong>Сохранение изображений</strong></p>
                    <i>imwrite(image, filename )</i>
                    <i>imwrite(image, filename, format)</i>
                    <i>imwrite(image, map, filename )</i>
                    <i>imwrite(…, param_1, value_1, …)</i>
                    <p>Изображение image может быть двоичным, в оттенках серого, RGB или много-мерным изображением. Размер и класс image должны быть такими же, как и при чтении с помощью imread. Если это индексированное изображение, необходимо также указать карту цветов.</p>
                    <p>Если формат не указан, используется расширение для определения формата. Фактические поддерживаемые форматы зависят от параметров, сделанных во время сборки Octave. Можно использовать <strong>imformats</strong> для проверки поддержки различных форматов изображений.</p>
                    <p>В зависимости от формата файла можно настроить запись изображений парами параметров, значений. Поддерживаются следующие параметры:
                    <ul>
                        <li><strong>“Alpha”</strong>. Альфа-канал (прозрачность) изображения. Это должна быть матрица того же класса и количества строк и столбцов image. В случае многостраничного изображения размер 4-го измерения также должен совпадать, а третий размер должен быть одноэлементным. По умолчанию изображение будет полностью непрозрачным.</li>
                        <li><strong>“Compression”</strong>. Сжатие использует одно изображение. Может быть од-ним из следующих: none (по умолчанию), bzip, fax3, fax4, jpeg, lzw, rle или deflate. Не все типы сжатия доступны для форматов изображений, в которых по умолчанию используется библиотека Magick.</li>
                        <li><strong>“DelayTime”</strong>. Для форматов, поддерживающих анимацию (например, GIF), определяет, как долго отображается кадр, пока он не перейдет к следующему. Значение должно быть скалярным или вектором длины, равной количеству кадров в image. Значение указывается в секундах, должно находиться в диапазоне от 0 до 655,35 и по умолчанию равно 0,5.</li>
                        <li><strong>“DisposalMethod”</strong>. Для форматов, поддерживающих анимацию (напри-мер, GIF), управляет тем, что происходит с кадром перед отрисовкой следующего. Его значение может быть одной из следующих строк: doNotSpecify (по умолчанию); leaveInPlace; restoreBG и restorePrevious или массивом ячеек из этих строк с длиной, равной количеству кадров в image.</li>
                        <li><strong>“LoopCount”</strong>. Для форматов, поддерживающих анимацию (например, GIF), определяет, сколько раз повторяется последовательность. Значение Inf означает бесконечный цикл (по умолчанию), значение 0 или 1 означа-ет, что последовательность воспроизводится только один раз (зациклива-ется ноль раз).</li>
                        <li><strong>“Quality”</strong>. Установливает качество сжатия. Значение должно быть целым числом от 0 до 100, причем большие значения указывают на более высо-кое визуальное качество и более низкое сжатие. По умолчанию 75.</li>
                        <li><strong>“WriteMode”</strong>. Некоторые форматы файлов, такие как TIFF и GIF, позво-ляют хранить несколько изображений в одном файле. Эта опция указыва-ет, следует ли добавить image к файлу (если он существует) или для него следует создать новый файл (возможно, перезаписав существующий файл). Значение должно быть строкой Overwrite (по умолчанию) или Append.</li>
                    </ul>
                    </p>

                    <h3 class="section__suptitle">Загрузка и сохранение изображений</h3>
                    <p>Информацию о файле изображения на диске, фактически не читая его в Octave, можно получить с помощью функции <strong>iminfo</strong>.</p>
                    <p><i>info = imfinfo(filename)</i>
                    <i>info = imfinfo(URL)</i>
                    <i>info = imfinfo(…, format)</i>
                    Информация о файле содержит следующие поля:</p>
                    <ul>
                        <li><b>FileName</b> – полное имя файла.</li>
                        <li><b>FileModDate</b> – дата последнего изменения файла.</li>
                        <li><b>FileSize</b> – размер файла в байтах.</li>
                        <li><b>Format</b> – формат изображения.</li>
                        <li><b>Height</b> – высота изображения в пикселях.</li>
                        <li><b>Width</b> – ширина изображения в пикселях.</li>
                        <li><b>BitDepth</b> – количество бит в канале на пиксель.</li>
                        <li><b>ColorType</b> – тип изображения.</li>
                        <li><b>XResolution</b> – разрешение изображения по X.</li>
                        <li><b>YResolution</b> – разрешение изображения по Y.</li>
                        <li><b>ResolutionUnit</b> – Единицы разрешения изображения.</li>
                        <li><b>DelayTime</b> – Время в 1/100 секунды (от 0 до 65535) между кадрами.</li>
                        <li><b>LoopTime</b> – количество зацикливаний.</li>
                        <li><b>ByteOrder</b> – Вариант Endian для форматов, которые его поддерживают.</li>
                        <li><b>Gamma</b> – гамма-уровень изображения.</li>
                        <li><b>Quality</b> – Уровень сжатия JPEG/MIFF/PNG. Значение в диапазоне [0 100].</li>
                        <li><b>DisposalMethod</b> – Управляет визуализацией последовательных кадров (только для GIF).</li>
                        <li><b>Chromaticities</b> – матрица 1x8 со значениями цветности x,y для белых, красных, зеленых и синих точек в указанном порядке.</li>
                        <li><b>Comment</b> – комментарий к изображению.</li>
                        <li><b>Compression</b> – тип сжатия.</li>
                        <li><b>Colormap</b> – цветовая карта.</li>
                        <li><b>Orientation</b> – ориентация изображения относительно строк и столбцов.</li>
                        <li><b>Software</b> – название и версия ПО или прошивки камеры или устройства ввода изображения, используемого для создания изображения.</li>
                        <li><b>Make</b> – производитель записывающего оборудования.</li>
                        <li><b>Model</b> – модель записывающего оборудования.</li>
                        <li><b>DateTime</b> – дата и время создания изображения.</li>
                        <li><b>ImageDescription</b> – название изображения согласно стандарту Exif.</li>
                        <li><b>Artist</b> – Имя владельца камеры, фотографа или создателя изображения.</li>
                        <li><b>Copyright</b> – уведомление об авторских правах.</li>
                        <li><b>DigitalCamera</b> – структура с информацией, полученной из тега Exif.</li>
                        <li><b>GPSInfo</b> – структура с информацией о геотегах, полученной из тега Exif.</li>
                    </ul>

                    <h3 class="section__suptitle">Отображение изображений</h3>
                    <p>Функцией для визуализации изображения является <strong>imshow</strong>. Она показы-вает изображение, указанное в первом входном аргументе.</p>
                    <i>imshow(image)</i>
                    <i>imshow(image, limits)</i>
                    <i>imshow(image, map)</i>
                    <i>imshow(rgb, …)</i>
                    <i>imshow(filename)</i>
                    <i>imshow(…, string_param_1, value_1, …)</i>
                    <p>Функция отображает изображение image, где image может быть 2-мерной (в от-тенках серого) или 3-мерной (RGB) матрицей.
                    Если limit является 2-элементным вектором [low, high], изображение отобража-ется с использованием диапазона отображения между low и high. Если для limit передается пустая матрица, диапазон отображения вычисляется как диапазон между минимальным и максимальным значением на изображении.</p>
                    <p>Если map является допустимой картой цветов, изображение будет показано как проиндексированное изображение с использованием прилагаемой карты цветов.</p>
                    <p>Вывод изображений можно настроить с помощью пар параметров, значений. Парметрами могут быть:
                    <ul>
                        <li><strong>“displayrange”</strong>, где value_1 – диапозон отображения.</li>
                        <li><strong>“colormap”</strong>, где value_1 – цветовая карта.</li>
                        <li><strong>“xdata”</strong>. Если value_1 – 2-элементный вектор, он должен содержать горизонтальные границы изображения в виде [xfirst, xlast], где xfirst и xlast — абсцисса центров угловых пикселей. В противном случае value_1 должен быть вектором, и только первый и последний элементы будут использоваться для xfirst и xlast соответственно.</li>
                        <li><strong>“ydata”</strong>. Если value_1 – 2-элементный вектор, он должен содержать горизонтальные границы изображения в виде [yfirst, ylast], где yfirst и ylast — абсцисса центров угловых пикселей. В противном случае value_1 должен быть вектором, и только первый и последний элементы будут использоваться для yfirst и ylast соответственно.</li>
                    </ul>
                    <p><strong>Функция image</strong></p>
                    <p>Чтобы отобразить матрицу как индексированное цветное изображение ис-пользуется функция <strong>image</strong>.</p>
                    <i>image(img)</i>
                    <i>image(x, y, img)</i>
                    <i>image(prop_1, value_1, …)</i>
                    <i>image(…, prop_1, value_1, …)</i>
                    <p>x и y являются необязательными 2-элементными векторами [min, max], ко-торые задают координаты центров угловых пикселей.</p>
                    <p>Начало координат (0, 0) для изображений расположено в левом верхнем уг-лу. Для обычных графиков начало координат находится внизу слева. Octave обрабатывает эту инверсию, отображая данные в обычном режиме, а затем изменяя направление оси Y на противоположное, устанавливая для ydir свойства значение reverse.</p>
                    <p>Функцию image можно вызывать в двух формах: высокоуровневой и низко-уровневой. При вызове с обычными параметрами используется форма высо-кого уровня, которая сначала вызывает newplot подготовку графической фи-гуры и осей. Когда единственными входными данными image являются пары свойство/значение, используется низкоуровневая форма, которая создает но-вый экземпляр объекта изображения и вставляет его в текущие оси.</p>
                    <p><strong>Функция imagesc</strong></p>
                    <p>Для отображения масштабированной версии матрицы img используется функция <strong>imagesc</strong>.</p>
                    <i>imagesc(img)</i>
                    <i>imagesc(x, y, img)</i>
                    <i>image(…, climits)</i>
                    <i>imagesc(hax, …)</i>
                    <i>imagesc(prop_1, value_1, …)</i>
                    <i>imagesc(…, prop_1, value_1, …)</i>
                    <p>Цветовая карта масштабируется так, что элементы матрицы занимают всю цветовую карту. Если climits = [lo, hi] указано, то этот диапазон устанавлива-ется равным текущей оси.</p>
                    <p>x и y являются необязательными 2-элементными векторами [min, max], ко-торые задают координаты центров угловых пикселей.</p>
                    <p>Функцию imagesc можно вызывать в двух формах: высокоуровневой и низ-коуровневой. При вызове с обычными параметрами используется форма вы-сокого уровня, которая сначала вызывает newplot подготовку графической фигуры и осей. Когда единственными входными данными image являются пары свойство/значение, используется низкоуровневая форма, которая со-здает новый экземпляр объекта изображения и вставляет его в текущие оси.</p>

                    <h3 class="section__suptitle">Представление изображений</h3>
                    <p>Octave поддерживает четыре различных типа изображений: изображения в оттенках серого, изображения RGB, бинарные изображения и индексирован-ные изображения. Изображение в оттенках серого представлено матрицей MxN, в которой каждый элемент соответствует интенсивности пикселя. Изображение RGB представлено массивом MxNx3, где каждый третий вектор соответствует интенсивности красного, зеленого и синего каждого пикселя.</p>
                    <p>Фактическое значение пикселя в изображении в оттенках серого или RGB зависит от класса матрицы. Если матрица относится к классу double, то интен-сивность пикселей находится в диапазоне от 0 до 1, если это класс uint8, то ин-тенсивность находится в диапазоне от 0 до 255, а если это класс uint16, то ин-тенсивность находится в диапазоне от 0 до 65535.</p>
                    <p>Бинарное изображение представляет собой матрицу размера Mx N класса logical. Пиксель в бинарном изображении черный, если false и белый, если true.</p>
                    <p>Индексированное изображение состоит из матрицы целых чисел MxN и цветовой карты. Каждое целое число соответствует индексу на карте цветов, а каждая строка на карте цветов соответствует цвету RGB. Цветовая карта долж-на относиться к классу double со значениями от 0 до 1.</p>

                    <h3 class="section__suptitle">Преобразование форматов изображений</h3>
                    <p>Для преобразования изображения в double доступна функция <strong>im2double</strong>.</p>
                    <i>im2double(image)</i>
                    <i>im2double(image, “indexed”)</i>
                    <p>В случае индексированного изображения вторым аргументом функции указывается indexed.
                    Для преобразования изображения в оттенках серого или бинарного изоб-ражения в индексированное доступна функция <strong>gray2ind</strong>.</p>
                    <i>gray2ind(img)</i>
                    <i>gray2ind(img, n)</i>
                    <i>gray2ind(BW)</i>
                    <i>gray2ind(BW, n)</i>
                    <p>Индексированное изображение будет состоять из n различных значений интен-сивности. Если значение n не задано, по умолчанию используется значение 64 для изображений в оттенках серого или 2 для бинарных черно-белых изобра-жений.</p>
                    <p>Для преобразования изображения RGB в индексированное доступна функция <strong>rgb2ind</strong>.</p>
                    <i>rgb2ind(rgb)</i>
                    <i>rgb2ind(R, G, B)</i>
                    <p>Входное изображение rgb может быть указано как единая матрица размера MxNx3 или как три отдельные переменные, R, G и B , три цветовых канала: красный, зеленый и синий.</p>
                    <p>Для преобразования индексированного изображения в изображение RGB доступна функция <strong>ind2rgb</strong>.</p>
                    <i>ind2rgb(x, map)</i>
                    <p>Изображение x должно быть индексированным изображением, которое будет преобразовано с использованием карты цветов. Если карта не содержит доста-точного количества цветов для изображения, пиксели в x за пределами диапа-зона сопоставляются с последним цветом на карте.</p>
                    <p>Функция <strong>colormap</strong> используется для изменения цветовой карты текущих осей или фигуры.</p>
                    <i>colormap()</i>
                    <i>colormap(map)</i>
                    <i>colormap(“default”)</i>
                    <i>colormap(map_name)</i>
                    <p>Без входных параметров colormapвозвращает текущую карту цветов.</p>
                    <p><strong>colormap(map)</strong> устанавливает текущую палитру в map.</p>
                    <p><strong>colormap(“default”)</strong> восстанавливает цветовую карту по умолчанию.</p>
                    <p>Цветовая карта также может быть указана строкой map_name, которая является именем функции, возвращающей цветовую карту.
                    <p>Функция <strong>iscolormap(cmap)</strong> возвращает true, если cmap является цветовой кар-той.</p>
                    <p>Функция <strong>whitebg()</strong> позволяет инвертировать цвета в текущей цветовой схеме.</p>

                    <h3 class="section__suptitle">Построения поверх изображений</h3>
                    <p>Поскольку изображение представляет собой матрицу, оно индексируется значениями строк и столбцов. Однако система построения графиков основана на традиционной системе (x, y). Чтобы свести к минимуму разницу между дву-мя системами, Octave помещает начало системы координат в точку, соответ-ствующую пикселю в точке (1, 1). Таким образом, чтобы нанести точки, задан-ные значениями строки и столбца, поверх изображения, нужно вызвать plot со значениями столбца в качестве первого аргумента и значениями строки в каче-стве второго аргмента. В качестве примера следующий код генерирует изобра-жение со случайной интенсивностью от 0 до 1 и показывает изображение с красными кружками над пикселями с интенсивностью выше 0,99.</p>
                    <div class="code">
                        <span>
                            I = rand(100, 100);<br>
                            [row, col] = find(I > 0.99);<br>
                            hold(“on”);<br>
                            imshow (I);<br>
                            plot(col, row, “ro”);<br>
                            hold(“off”);
                        </span>
                    </div>

                    <h3 class="section__suptitle">Преобразование цвета</h3>
                    <p>Цвет в пространстве RGB состоит из красных, зеленых и синих интенсив-ностей. Цвет в пространстве HSV представлен уровнями оттенка, насыщенно-сти и значениями (яркостью) в цилиндрической системе координат.</p>
                    <p>Octave поддерживает преобразование из цветовой системы RGB в цвето-вую систему HSV и наоборот. Также возможно преобразовать цветное изобра-жение RGB в изображение в оттенках серого.</p>
                    <p>Для преобразования цветовой карты или изображения из цветового про-странства RGB в цветовое пространство HSV предназначена функция <strong>rgb2hvs()</strong> и наоборот <strong>hvs2rgb()</strong>. Входными данными могут быть как цветовая карта, так и изображение.</p>
                    <p>Для преобразования изображения или цветовой карты из цветового про-странства красно-зелено-синий (RGB) в изображение с интенсивностью оттен-ков серого предназначена функция <strong>rgb2gray()</strong>. Входные данные могут отно-ситься к классу uint8, int8, uint16, int16, single или double, выходные данные то-го же класса.</p>
                </div>
            </div>
        </div>
    </section>

    <p style="text-indent: 0; text-align: center;"><em>Использованный источник: <a href="https://docs.octave.org/v7.1.0/Image-Processing.html"  target="_blank">docs.octave.org</a></em></p>

    <footer class="footer" id="footer">
        <div class="container">
                <div class="footer__text">
                    <img src="img/sfedu_logo.png" alt="">
                    <p>Институт математики, механики и компьютерных наук им. И.И. Воровича</p>   
                </div>
            <div class="copyright">
                <span>&copy 2023 OctaveImg by <a href="https://github.com/XydeWebDev" target="_blank">XydeWebDev</a></span>
            </div>
        </div>
    </footer>
</div>

<script src="script.js"></script>

</body>
</html>